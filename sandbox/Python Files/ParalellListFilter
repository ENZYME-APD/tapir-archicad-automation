import Grasshopper as gh
from Grasshopper import DataTree
from Grasshopper.Kernel.Data import GH_Path
import System

# Set component UI
ghenv.Component.Name = "Parallel List Filter"
ghenv.Component.Nickname = "PLFilter"

def filter_lists(primary_list, secondary_list, search_values, filter_mode):
    # Ensure search_values is a list
    if not isinstance(search_values, list):
        search_values = [search_values] if search_values is not None else []
    
    # Initialize output lists or trees
    filtered_primary = []
    filtered_secondary = []
    pattern = []
    
    if primary_list is not None and secondary_list is not None and filter_mode:
        # Check if lists have matching lengths
        if len(primary_list) != len(secondary_list):
            message = f"Error: Lists must have equal length.\nprimList: {len(primary_list)}, secList: {len(secondary_list)}"
            return filtered_primary, filtered_secondary, pattern, message
        
        pattern = [False] * len(primary_list)  # Initialize pattern with False
        
        if filter_mode == "equals":
            for i, val in enumerate(primary_list):
                if val in search_values:
                    filtered_primary.append(val)
                    filtered_secondary.append(secondary_list[i])
                    pattern[i] = True
            message = f"Equals {search_values}\nFound {len(filtered_primary)}/{len(primary_list)}"
        
        elif filter_mode == "notFound":
            for i, val in enumerate(primary_list):
                if val not in search_values:
                    filtered_primary.append(val)
                    filtered_secondary.append(secondary_list[i])
                    pattern[i] = True
            message = f"Not Found in 'sValues' \n Not found {len(filtered_primary)}/{len(primary_list)}"
        
        elif filter_mode == "greater":
            for i, val in enumerate(primary_list):
                if val > max(search_values):
                    filtered_primary.append(val)
                    filtered_secondary.append(secondary_list[i])
                    pattern[i] = True
            message = f"Greater than {max(search_values)}\nFound {len(filtered_primary)}/{len(primary_list)}"
        
        elif filter_mode == "smaller":
            for i, val in enumerate(primary_list):
                if val < min(search_values):
                    filtered_primary.append(val)
                    filtered_secondary.append(secondary_list[i])
                    pattern[i] = True
            message = f"Smaller than {min(search_values)}\nFound {len(filtered_primary)}/{len(primary_list)}"
        
        elif filter_mode == "range" and len(search_values) >= 2:
            min_val, max_val = min(search_values), max(search_values)
            for i, val in enumerate(primary_list):
                if min_val <= val <= max_val:
                    filtered_primary.append(val)
                    filtered_secondary.append(secondary_list[i])
                    pattern[i] = True
            message = f"Range {min_val} to {max_val}\nFound {len(filtered_primary)}/{len(primary_list)}"
        
        elif filter_mode == "closest":
            mapped_values = set()
            for i, val in enumerate(primary_list):
                closest_val = min(search_values, key=lambda x: abs(x - val))
                filtered_primary.append(closest_val)
                filtered_secondary.append(secondary_list[i])
                pattern[i] = True
                mapped_values.add(closest_val)
            message = f"Closest to {search_values}\nMapped to {len(mapped_values)} values"
        
        elif filter_mode == "group_equals":
            tree_primary = DataTree[object]()
            tree_secondary = DataTree[object]()
            groups = {val: [] for val in search_values}
            
            for i, val in enumerate(primary_list):
                if val in search_values:
                    groups[val].append(i)
                    pattern[i] = True
            
            total_matches = 0
            for idx, search_val in enumerate(search_values):
                path = GH_Path(idx)
                prim_values = [primary_list[i] for i in groups.get(search_val, [])]
                sec_values = [secondary_list[i] for i in groups.get(search_val, [])]
                if prim_values:
                    tree_primary.AddRange(prim_values, path)
                    tree_secondary.AddRange(sec_values, path)
                total_matches += len(prim_values)
            
            branch_count = len(search_values)
            message = f"Group Equals {search_values}\nFound {total_matches} in {branch_count} branches"
            return tree_primary, tree_secondary, pattern, message
        
        elif filter_mode == "group_unique":
            tree_primary = DataTree[object]()
            tree_secondary = DataTree[object]()
            unique_values = list(set(secondary_list))  # Get unique values from secList
            groups = {val: [] for val in unique_values}
            
            for i, val in enumerate(secondary_list):
                groups[val].append(i)
                pattern[i] = True  # All items are grouped, so mark as True
            
            total_matches = 0
            for idx, unique_val in enumerate(unique_values):
                path = GH_Path(idx)
                prim_values = [primary_list[i] for i in groups.get(unique_val, [])]
                sec_values = [secondary_list[i] for i in groups.get(unique_val, [])]
                if prim_values:
                    tree_primary.AddRange(prim_values, path)
                    tree_secondary.AddRange(sec_values, path)
                total_matches += len(prim_values)
            
            branch_count = len(unique_values)
            message = f"Group Unique from secList\nFound {total_matches} in {branch_count} branches"
            return tree_primary, tree_secondary, pattern, message
        
        else:
            message = f"Invalid filter mode. Use 'equals', 'notFound', 'greater', 'smaller', 'range', 'closest', 'group_equals', or 'group_unique'."
    
    else:
        message = "Waiting for all inputs to be provided."
    
    return filtered_primary, filtered_secondary, pattern, message

# Process the filtering
filteredPrim, filteredSec, filterPattern, msg = filter_lists(primList, secList, sValues, sMode)
ghenv.Component.Message = msg